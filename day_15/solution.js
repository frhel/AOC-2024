// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '15'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _OUTPUT_LENGTH = 50; // The length of the output line
const _ANSWERS = {};

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let input = readInputFile();
let data = parseInput(input);

let _DIRS = {'>': [1, 0], '<': [-1, 0], '^': [0, -1], 'v': [0, 1]};
let [map, moves] = data;
let _BOX = 'O';
let _WALL = '#';
let _BOT = '@';
let _BOT_POS = findBot(map);


_TIMERS.part_1 = performance.now(); // Start the timer for part 1
_ANSWERS.part1 = solvePart1(map, moves);
logAnswer(_ANSWERS.part1, 1);

_TIMERS.part_2 = performance.now(); // Start the timer for part 2
_ANSWERS.part2 = solvePart2(map, moves);
logAnswer(_ANSWERS.part2, 2);

printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Array} map - The map of the area
 * @param {Array} moves - The moves to make
 */
function solvePart1(map, moves) {

	let answer = 0;
	let map_copy = map.map(row => [...row]);

	for (let move of moves) {
		let [dx, dy] = _DIRS[move];
		let [x, y] = _BOT_POS;
		let [nx, ny] = [x + dx, y + dy];
		if (map_copy[ny][nx] === _BOX) {
			let boxes = [[nx, ny]];
			let [bx, by] = [nx + dx, ny + dy];

			while(map_copy[by][bx] === _BOX) {
				boxes.push([bx, by]);
				bx += dx;
				by += dy;
			}
			if (map_copy[by][bx] === _WALL) continue;
			else {
				while (boxes.length) {
					let [bx, by] = boxes.pop();
					let [nbx, nby] = [bx + dx, by + dy];
					map_copy[nby][nbx] = _BOX;
				}
				map_copy[y][x] = '.';
				map_copy[ny][nx] = _BOT;
				_BOT_POS = [nx, ny];
			}
		} else if (map_copy[ny][nx] === '.') {
			map_copy[y][x] = '.';
			map_copy[ny][nx] = _BOT;
			_BOT_POS = [nx, ny];
		}
	}


	for (let y = 0; y < map_copy.length; y++) {
		for (let x = 0; x < map_copy[y].length; x++) {
			if (map_copy[y][x] === _BOX) {
				answer += y * 100 + x;
			}
		}
	}


	return answer;
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart2(map, moves) {

	let answer = 0;

	let [map_copy, boxes] = alterMap(map);
	_BOX = ['[', ']'];
	_BOT_POS = findBot(map_copy);

	for (let move of moves) {
		let [dx, dy] = _DIRS[move];
		let [x, y] = _BOT_POS;
		let [nx, ny] = [x + dx, y + dy];
		if (_BOX.includes(map_copy[ny][nx])) {
			let found = [];
			// console.log(boxes, ny, nx, map_copy[ny][nx])
			let box = boxes.find(box => (box.xl === nx || box.xr === nx) && box.y === ny);
			found.push(box);
			// console.log(box)
			let [bx, by] = [nx + dx * 2, ny + dy];
			if (dy !== 0) found = [...found, ...findBoxes(box, boxes, map_copy, dx, dy)];
			else {
				while (_BOX.includes(map_copy[by][bx])) {
					let box = boxes.find(box => (box.xl === bx || box.xr === bx) && box.y === by);
					found.push(box);
					bx += dx * 2;
					by += dy;
				}
			}
			if (found.includes(_WALL)) continue;
			if (map_copy[by][bx] === _WALL) continue;
			else {
				let processed = [];
				let empty = [];
				while (found.length > 0) {
					let curr_box = found.pop();
					empty.push(`${curr_box.xl},${curr_box.y}`);
					empty.push(`${curr_box.xr},${curr_box.y}`);
					let curr_box_idx = boxes.every((box, idx) => {
						if (box.xl === curr_box.xl && box.xr === curr_box.xr && box.y === curr_box.y) return idx;
					})
					curr_box.xl += dx;
					curr_box.xr += dx;
					curr_box.y += dy;
					map_copy[curr_box.y][curr_box.xl] = '[';
					map_copy[curr_box.y][curr_box.xr] = ']';
					boxes[curr_box_idx] = curr_box;
					processed.push(`${curr_box.xl},${curr_box.y}`);
					processed.push(`${curr_box.xr},${curr_box.y}`);

				}
				for (let blank of empty) {
					if (processed.includes(blank)) continue;
					let [bx, by] = blank.split(',').map(Number);
					map_copy[by][bx] = '.';
				}
				map_copy[y][x] = '.';
				map_copy[ny][nx] = _BOT;
				_BOT_POS = [nx, ny];
			}
		} else if (map_copy[ny][nx] === '.') {
			map_copy[y][x] = '.';
			map_copy[ny][nx] = _BOT;
			_BOT_POS = [nx, ny];
		}
	}

	for (let y = 0; y < map_copy.length; y++) {
		for (let x = 0; x < map_copy[y].length; x++) {
			if (map_copy[y][x] === '[')
				answer += y * 100 + x;
		}
	}

	return answer;
}

function findBoxes(box, boxes, map, dx, dy, found = []) {
	// console.log('Box:', box)
	let [bxl, bxr, by] = [box.xl + dx, box.xr + dx, box.y + dy];
	// console.log('bxl:', bxl, 'bxr:', bxr, 'by:', by)
	if (map[by][bxl] === _WALL || map[by][bxr] === _WALL) {
		found.push(_WALL);
		return found;
	}

	if (_BOX.includes(map[by][bxl])) {
		let curr_box = boxes.find(box => (box.xl === bxl || box.xr) === bxl && box.y === by);
		// console.log('curr_box:', curr_box)
		if (curr_box !== undefined && !found.includes(curr_box)) {
			found.push(curr_box);
			found = [...findBoxes(curr_box, boxes, map, dx, dy, found)];
		}
	}
	if (_BOX.includes(map[by][bxr])) {
		let curr_box = boxes.find(box => (box.xl === bxr || box.xr === bxr) && box.y === by);
		if (curr_box !== undefined && !found.includes(curr_box)) {
			found.push(curr_box);
			found = [...findBoxes(curr_box, boxes, map, dx, dy, found)];
		}
	}

	if (found.length === 0) return [];

	return found;


}

function alterMap(map) {
	let newMap = [];
	let boxes = [];
	for (let y = 0; y < map.length; y++) {
		let row = [];
		for (let x = 0; x < map[y].length; x++) {
			if (map[y][x] === _BOT) {
				row.push(_BOT, '.');
			} else if (map[y][x] === _BOX) {
				row.push('[', ']');
				let box = {xl: row.length - 2, xr: row.length - 1, y: y};
				boxes.push(box);

			} else if (map[y][x] === _WALL) {
				row.push('#', '#');
			} else row.push('.', '.');
		}
		newMap.push(row);
	}
	return [newMap, boxes];
}

function findBot(map) {
	for (let y = 0; y < map.length; y++) {
		for (let x = 0; x < map[y].length; x++) {
			if (map[y][x] === _BOT) return [x, y];
		}
	}
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {

	let data = input.split('\n\n');
	let map = data[0].split('\n').map(row => row.split(''));
	let moves = data[1].split('').filter(move => move !== '\n');
	return [map, moves];

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Check if a given coordinate is within the bounds of a grid
 * @param {Array} grid - The grid to check against
 * @param {Number} x - The x coordinate to check
 * @param {Number} y - The y coordinate to check
 * @returns {Boolean} - Whether the coordinate is within the grid
 */
function isWithinBounds(grid, x, y) {
	return x >= 0 && x < grid[0].length && y >= 0 && y < grid.length;
}

/**
 * Print a given grid to the console
 * @param {Array} grid - The grid to print
 */
function printGrid(grid, reverse = false) {
	let out = '';
	if (reverse) grid = grid.reverse();
	grid.forEach(row => {
		out += row.join('') + '\n';
	});
	console.log(out);
}

/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Pick the best time unit for a given time
 * @param {Number} time - The time to pick a unit for
 * @returns {Array} - An array with the time and the unit
 */
function pickTimeUnit(time) {
	if (time < 1) return [time * 1000, 'Âµs'];
	else if (time < 1000) return [time, 'ms'];
	else if (time < 60000) return [time / 1000, 's'];
	else if (time < 3600000) return [time / 60000, 'm'];
	else return [time / 3600000, 'h'];
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function logAnswer(answer, part) {
	let time = performance.now();
	time = time - _TIMERS[`part_${part}`];
	let time_unit = pickTimeUnit(time);
	let static_length = 31;
	let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Part ' + part + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-] in'), chalk.green.bold('[- ' + (time_unit[0]).toFixed(4)), chalk.red(time_unit[1]), chalk.green.bold('-]'));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}

function logBothAnswers(answers) {
	let time = performance.now();
	time = time - _TIMERS['both'];
	let static_length = 12;
	let time_unit = pickTimeUnit(time);
	answers.forEach((answer, i) => {
		let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
		let output = chalk(chalk.bold.white('Part ' + (i + 1) + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-]'));
		console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	})
	static_length =35
	let line_length = static_length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Time For Both Parts: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}


/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.log('\n');
	let title = `-= DAY ${day} =-`;
	let line_length = (_OUTPUT_LENGTH - (title.length) - 2) / 4;
	console.info(chalk.bold.blue('-'.repeat(Math.ceil(line_length)), `${chalk.bold.white(title)}`, '-'.repeat(line_length * 3)));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	let time = performance.now();
	time = time - _TIMERS.global;
	let time_unit = pickTimeUnit(time);
	let static_length = 26;
	let line_length = static_length + time.toFixed(4).length;
	let output = chalk(chalk.bold.white('Total Time: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	console.log('\n');
}
// ************ End of Helper Functions ************