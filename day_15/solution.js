// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '15'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _OUTPUT_LENGTH = 50; // The length of the output line
const _ANSWERS = {};

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let input = readInputFile();
let data = parseInput(input);

let _DIRS = {'>': [1, 0], '<': [-1, 0], '^': [0, -1], 'v': [0, 1]};
let [map, moves] = data;
let _BOX = 'O';
let _WALL = '#';
let _BOT = '@';
let _BOT_POS = findBot(map);


_TIMERS.part_1 = performance.now(); // Start the timer for part 1
_ANSWERS.part1 = solvePart1(map, moves);
logAnswer(_ANSWERS.part1, 1);

_TIMERS.part_2 = performance.now(); // Start the timer for part 2
_ANSWERS.part2 = solvePart2(map, moves);
logAnswer(_ANSWERS.part2, 2);

printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Array} map - The map of the area
 * @param {Array} moves - The moves to make
 */
function solvePart1(map, moves) {

	let answer = 0;
	// Create a deep copy of the map
	let map_copy = map.map(row => [...row]);

	// Iterate over the moves
	for (let move of moves) {
		// Save the directions
		let dx = _DIRS[move][0];
		let dy = _DIRS[move][1];
		// Save the current position of the bot
		let x = _BOT_POS[0];
		let y = _BOT_POS[1];
		// Save the new position of the bot
		let nx = x + dx;
		let ny = y + dy;

		// If the new position is a box
		if (map_copy[ny][nx] === _BOX) {
			// Create an array to hold the boxes and add the current box to it
			let boxes = [[nx, ny]];

			// Check if there is another box in the same direction
			let bx = nx + dx;
			let by = ny + dy;

			// If there is a box in the same direction, add it to the boxes array
			// and keep adding boxes until there are no more boxes in the same direction
			while(map_copy[by][bx] === _BOX) {
				boxes.push([bx, by]);
				bx += dx;
				by += dy;
			}

			// If the next position after the boxes is a wall, skip any further processing
			// becaue the boxes can't be moved
			if (map_copy[by][bx] === _WALL) continue;
			else {
				// Else move the boxes we found
				while (boxes.length) {
					// Pop the last box from the boxes array
					let [bx, by] = boxes.pop();
					// Set the new position of the box
					let [nbx, nby] = [bx + dx, by + dy];
					// Update the map with the new box position
					map_copy[nby][nbx] = _BOX;
				}
				// Update the map with the new bot position
				map_copy[y][x] = '.'; // Set the old bot position on the map to empty
				map_copy[ny][nx] = _BOT; // Set the new bot position on the map to the bot
				_BOT_POS = [nx, ny]; // Update the bot's saved position
			}
		} else if (map_copy[ny][nx] === '.') {
			// If the new position is empty, move the bot
			map_copy[y][x] = '.'; // Set the old bot position on the map to empty
			map_copy[ny][nx] = _BOT; // Set the new bot position on the map to the bot
			_BOT_POS = [nx, ny]; // Update the bot's saved position
		}
	}

	// Iterate over the map to find the boxes and calculate the answer
	for (let y = 0; y < map_copy.length; y++) {
		for (let x = 0; x < map_copy[y].length; x++) {
			if (map_copy[y][x] === _BOX) {
				answer += y * 100 + x;
			}
		}
	}


	return answer;
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart2(map, moves) {

	let answer = 0;

	// Alter the map to be double the width and save the new, wider boxes
	// to an array of objects with left, right and y coordinates
	let [map_copy, boxes] = alterMap(map);
	// Alter the _BOX variable to be an array with the left and right box characters
	_BOX = ['[', ']'];
	// Find the updated bot position and save it
	_BOT_POS = findBot(map_copy);

	for (let move of moves) {
		// Save the directions
		let dx = _DIRS[move][0];
		let dy = _DIRS[move][1];

		// Save the current position of the bot
		let x = _BOT_POS[0];
		let y = _BOT_POS[1];

		// Save the new position of the bot
		let nx = x + dx;
		let ny = y + dy;

		// If the new position is either half of a box
		if (_BOX.includes(map_copy[ny][nx])) {
			// Define an array to hold the found boxes in the same direction
			let found = [];
			// Locate the object of the box in the boxes array and add it to the found array
			let box = boxes.find(box => (box.xl === nx || box.xr === nx) && box.y === ny);
			found.push(box);

			// To find a box in the same direction, we need to increment x axis by double the direction
			// Set the next box coordinates on the horizontal axis in case the direction is not vertical
			let bx = nx + dx * 2;
			let by = ny;

			// If the direction is vertical, we need to recursively find the boxes in the same direction
			// because the boxes are 2 characters wide, so there is a potential tree structure to traverse
			if (dy !== 0) found = [...found, ...findBoxes(box, boxes, map_copy, dx, dy)];
			else {
				// Else, handle the horizontal direction just like in part 1, except we need to increment by 2
				while (_BOX.includes(map_copy[by][bx])) {
					let box = boxes.find(box => (box.xl === bx || box.xr === bx) && box.y === by);
					found.push(box);
					bx += dx * 2;
					by += dy;
				}
			}

			// Check if the found array contains a wall, if it does, skip the processing
			// Also check if the new position is a wall, if it is, skip the processing
			if (found.includes(_WALL) || map_copy[by][bx] === _WALL) continue;
			else {
				// Create an array to hold the processed boxes and an array to hold the empty spaces
				let processed = [];
				let empty = []; // These are the empty spaces that the boxes will leave behind

				// Process all the boxes we found
				while (found.length > 0) {
					let curr_box = found.pop();

					// Push the old box coordinates to the empty array
					empty.push(`${curr_box.xl},${curr_box.y}`);
					empty.push(`${curr_box.xr},${curr_box.y}`);

					// Update the box coordinates with the new ones
					curr_box.xl += dx;
					curr_box.xr += dx;
					curr_box.y += dy;

					// Draw the new box on the map
					map_copy[curr_box.y][curr_box.xl] = '[';
					map_copy[curr_box.y][curr_box.xr] = ']';

					// Push the new box coordinates to the processed array
					processed.push(`${curr_box.xl},${curr_box.y}`);
					processed.push(`${curr_box.xr},${curr_box.y}`);

				}

				// Process the empty spaces and update the map
				for (let blank of empty) {
					// If the empty space has had another box put in it, skip it
					if (processed.includes(blank)) continue;
					// Else, update the map with the empty space
					let split = blank.split(',').map(Number);
					map_copy[split[1]][split[0]] = '.';
				}
				// Update the bot position on the map as well as the saved bot position
				map_copy[y][x] = '.';
				map_copy[ny][nx] = _BOT;
				_BOT_POS = [nx, ny];
			}
		} else if (map_copy[ny][nx] === '.') {
			// If the new position is empty, move the bot
			map_copy[y][x] = '.';
			map_copy[ny][nx] = _BOT;
			_BOT_POS = [nx, ny];
		}
	}

	// Calculate the answer by iterating over the map and finding the left side of each box
	for (let y = 0; y < map_copy.length; y++) {
		for (let x = 0; x < map_copy[y].length; x++) {
			if (map_copy[y][x] === '[')
				answer += y * 100 + x;
		}
	}

	return answer;
}

/**
 * Find all the boxes in the same vertical direction
 * @param {Object} box - The box object to find the boxes from
 * @param {Array} boxes - The array of all the boxes
 * @param {Array} map - The map of the area
 * @param {Number} dx - The x direction
 * @param {Number} dy - The y direction
 * @param {Array} found - The array of found boxes
 * @returns {Array} - The array of found boxes
 */
function findBoxes(box, boxes, map, dx, dy, found = []) {
	// increment all the box coordinates by the direction
	let [bxl, bxr, by] = [box.xl + dx, box.xr + dx, box.y + dy];

	// If the new box coordinates are a wall, add a wall to the found array and return it
	if (map[by][bxl] === _WALL || map[by][bxr] === _WALL) {
		found.push(_WALL);
		return found;
	}

	// If the new box coordinates contain a box character, find the box object and add it to the found array
	// Check the left side of the box
	if (_BOX.includes(map[by][bxl])) {
		let curr_box = boxes.find(box => (box.xl === bxl || box.xr) === bxl && box.y === by);

		// If the box is already in the found array, skip it
		if (curr_box !== undefined && !found.includes(curr_box)) {
			found.push(curr_box);
			// Recursively find the boxes using the current found box
			found = [...findBoxes(curr_box, boxes, map, dx, dy, found)];
		}
	}

	// Check the right side of the box
	if (_BOX.includes(map[by][bxr])) {
		let curr_box = boxes.find(box => (box.xl === bxr || box.xr === bxr) && box.y === by);
		if (curr_box !== undefined && !found.includes(curr_box)) {
			found.push(curr_box);
			found = [...findBoxes(curr_box, boxes, map, dx, dy, found)];
		}
	}

	return found;


}

/** Make a new map with every cell being double the width. Also return an array of box objects
 * @param {Array} map - The map to alter
 * @returns {Array} - The altered map
 * @returns {Array} - Array of box objects
 * */
function alterMap(map) {
	let newMap = [];
	let boxes = [];
	for (let y = 0; y < map.length; y++) {
		let row = [];
		for (let x = 0; x < map[y].length; x++) {
			if (map[y][x] === _BOT) {
				row.push(_BOT, '.');
			} else if (map[y][x] === _BOX) {
				row.push('[', ']');
				let box = {xl: row.length - 2, xr: row.length - 1, y: y};
				boxes.push(box);

			} else if (map[y][x] === _WALL) {
				row.push('#', '#');
			} else row.push('.', '.');
		}
		newMap.push(row);
	}
	return [newMap, boxes];
}

/**
 * Find the bot on the map
 * @param {Array} map - The map to find the bot on
 * @returns {Array} - The coordinates of the bot
 * */
function findBot(map) {
	for (let y = 0; y < map.length; y++) {
		for (let x = 0; x < map[y].length; x++) {
			if (map[y][x] === _BOT) return [x, y];
		}
	}
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {

	let data = input.split('\n\n');
	let map = data[0].split('\n').map(row => row.split(''));
	let moves = data[1].split('').filter(move => move !== '\n');
	return [map, moves];

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Check if a given coordinate is within the bounds of a grid
 * @param {Array} grid - The grid to check against
 * @param {Number} x - The x coordinate to check
 * @param {Number} y - The y coordinate to check
 * @returns {Boolean} - Whether the coordinate is within the grid
 */
function isWithinBounds(grid, x, y) {
	return x >= 0 && x < grid[0].length && y >= 0 && y < grid.length;
}

/**
 * Print a given grid to the console
 * @param {Array} grid - The grid to print
 */
function printGrid(grid, reverse = false) {
	let out = '';
	if (reverse) grid = grid.reverse();
	grid.forEach(row => {
		out += row.join('') + '\n';
	});
	console.log(out);
}

/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Pick the best time unit for a given time
 * @param {Number} time - The time to pick a unit for
 * @returns {Array} - An array with the time and the unit
 */
function pickTimeUnit(time) {
	if (time < 1) return [time * 1000, 'µs'];
	else if (time < 1000) return [time, 'ms'];
	else if (time < 60000) return [time / 1000, 's'];
	else if (time < 3600000) return [time / 60000, 'm'];
	else return [time / 3600000, 'h'];
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function logAnswer(answer, part) {
	let time = performance.now();
	time = time - _TIMERS[`part_${part}`];
	let time_unit = pickTimeUnit(time);
	let static_length = 31;
	let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Part ' + part + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-] in'), chalk.green.bold('[- ' + (time_unit[0]).toFixed(4)), chalk.red(time_unit[1]), chalk.green.bold('-]'));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}

function logBothAnswers(answers) {
	let time = performance.now();
	time = time - _TIMERS['both'];
	let static_length = 12;
	let time_unit = pickTimeUnit(time);
	answers.forEach((answer, i) => {
		let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
		let output = chalk(chalk.bold.white('Part ' + (i + 1) + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-]'));
		console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	})
	static_length =35
	let line_length = static_length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Time For Both Parts: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}


/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.log('\n');
	let title = `-= DAY ${day} =-`;
	let line_length = (_OUTPUT_LENGTH - (title.length) - 2) / 4;
	console.info(chalk.bold.blue('-'.repeat(Math.ceil(line_length)), `${chalk.bold.white(title)}`, '-'.repeat(line_length * 3)));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	let time = performance.now();
	time = time - _TIMERS.global;
	let time_unit = pickTimeUnit(time);
	let static_length = 26;
	let line_length = static_length + time.toFixed(4).length;
	let output = chalk(chalk.bold.white('Total Time: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	console.log('\n');
}
// ************ End of Helper Functions ************