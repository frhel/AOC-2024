// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '16'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _OUTPUT_LENGTH = 50; // The length of the output line
const _ANSWERS = {};

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let input = readInputFile();
let data = parseInput(input);

let _DIRS = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // Directions: Down, Right, Up, Left
let dirToChar = ['v', '>', '^', '<'];

_TIMERS.part_1 = performance.now(); // Start the timer for part 1
_ANSWERS.part1 = solvePart1(data);
logAnswer(_ANSWERS.part1, 1);

_TIMERS.part_2 = performance.now(); // Start the timer for part 2
_ANSWERS.part2 = solvePart2(data);
logAnswer(_ANSWERS.part2, 2);

printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart1(data) {

	let answer = 0;

	let seen = new Set();
	let queue = [];
	for (let i = 0; i < 4; i++) {
		queue = queueNext(queue, data.map[data.start[1]][data.start[0]], i, data.map, data.end);
		data.map[data.start[1]][data.start[0]].score = 0;
		data.map[data.start[1]][data.start[0]].turns = 0;
		seen.add(`${data.start[0]},${data.start[1]}`);
	}

	while (queue.length) {
		queue = queue.sort((a, b) => a.score - b.score);

		let current = queue.shift();

		if (current.x === data.end[0] && current.y === data.end[1]) {
			console.log('Winner:', current.score);
			answer = current.score;
			for (let i = 0; i < current.visited.length; i++) {
				data.map[current.visited[i][1]][current.visited[i][0]].char = dirToChar[data.map[current.visited[i][1]][current.visited[i][0]].dir];
			}

			break;
		}
		if (current.score > data.map[current.y][current.x].score) {
			continue;
		}
		data.map[current.y][current.x].score = current.score;
		data.map[current.y][current.x].turns = current.turns;
		data.map[current.y][current.x].dir = current.dir;

		for (let i = 0; i < 4; i++) {
			if (Math.abs(i - current.dir) === 2) {
				continue;
			}

			queue = queueNext(queue, current, i, data.map, data.end);
		}
	}

	// High: 617936, 194648, 365200, 208712, 110516
	return answer
}

function queueNext(queue, current, dir, map, end) {
	let x = current.x + _DIRS[dir][0];
	let y = current.y + _DIRS[dir][1];
	if (isWithinBounds(map, x, y) && map[y][x].char !== '#') {

		let new_score = 0;

		let next = {};
		if (dir === current.dir) {
			next.score = current.score + 1;
			next.turns = current.turns;
		} else {
			next.score = current.score + 1001;
			next.turns = current.turns + 1;
			map[y][x].char = dirToChar[dir];
		}

		if (map[y][x].score * map[y][x].turns < next.score * next.turns) {
			return queue;
		}


		next.x = x;
		next.y = y;
		next.char = current.char;
		next.last_dir = current.dir;
		next.dir = dir;
		next.visited = [...current.visited, [x, y]];



		queue.push(next);
	}
	return queue;
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart2(data) {

	let answer = 0;


	return answer;
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {
	let start = [];
	let end = [];
	let map = input.split('\n').map((row, y) => {
		return row.split('').map((col, x) => {
			if (col === 'S') start = [x, y];
			if (col === 'E') end = [x, y];
			return {x, y, char: col, dir: 0, last_dir: 0, score: Infinity, turns: 0, visited: []};
		})
	})
	return {map, start, end};

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Check if a given coordinate is within the bounds of a grid
 * @param {Array} grid - The grid to check against
 * @param {Number} x - The x coordinate to check
 * @param {Number} y - The y coordinate to check
 * @returns {Boolean} - Whether the coordinate is within the grid
 */
function isWithinBounds(grid, x, y) {
	return x >= 0 && x < grid[0].length && y >= 0 && y < grid.length;
}

/**
 * Print a given grid to the console
 * @param {Array} grid - The grid to print
 */
function printGrid(grid, reverse = false) {
	let out = '';
	if (reverse) grid = grid.reverse();
	grid.forEach(row => {
		out += row.join('') + '\n';
	});
	console.log(out);
}

/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Pick the best time unit for a given time
 * @param {Number} time - The time to pick a unit for
 * @returns {Array} - An array with the time and the unit
 */
function pickTimeUnit(time) {
	if (time < 1) return [time * 1000, 'Âµs'];
	else if (time < 1000) return [time, 'ms'];
	else if (time < 60000) return [time / 1000, 's'];
	else if (time < 3600000) return [time / 60000, 'm'];
	else return [time / 3600000, 'h'];
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function logAnswer(answer, part) {
	let time = performance.now();
	time = time - _TIMERS[`part_${part}`];
	let time_unit = pickTimeUnit(time);
	let static_length = 31;
	let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Part ' + part + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-] in'), chalk.green.bold('[- ' + (time_unit[0]).toFixed(4)), chalk.red(time_unit[1]), chalk.green.bold('-]'));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}

function logBothAnswers(answers) {
	let time = performance.now();
	time = time - _TIMERS['both'];
	let static_length = 12;
	let time_unit = pickTimeUnit(time);
	answers.forEach((answer, i) => {
		let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
		let output = chalk(chalk.bold.white('Part ' + (i + 1) + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-]'));
		console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	})
	static_length =35
	let line_length = static_length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Time For Both Parts: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}


/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.log('\n');
	let title = `-= DAY ${day} =-`;
	let line_length = (_OUTPUT_LENGTH - (title.length) - 2) / 4;
	console.info(chalk.bold.blue('-'.repeat(Math.ceil(line_length)), `${chalk.bold.white(title)}`, '-'.repeat(line_length * 3)));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	let time = performance.now();
	time = time - _TIMERS.global;
	let time_unit = pickTimeUnit(time);
	let static_length = 26;
	let line_length = static_length + time.toFixed(4).length;
	let output = chalk(chalk.bold.white('Total Time: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	console.log('\n');
}
// ************ End of Helper Functions ************