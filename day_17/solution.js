// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '17'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _OUTPUT_LENGTH = 50; // The length of the output line
const _ANSWERS = {};

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let input = readInputFile();
let [registers, program] = parseInput(input);
let _INSTRUCTIONS = {
	0: 'adv', // Divide the value in register A by the value of the combo operand to the power of 2, write it to register A
	1: 'bxl', // Calculate the bitwise XOR of register B and the literal operand, write it to register B
	2: 'bst', // Modulo the value of combo operand by 8, write it to register B
	3: 'jnz', // Do nothing if the value of register A is nothing, otherwise move the instruction pointer to the value of its literal operand. Only increase instruction by 1 after this instruction if pointer is moved
	4: 'bxc', // Bitwise XOR of register B and register C, write it to register B. Store in register B
	5: 'out', // Calculate value of combo operand modulo 8 and write it to the output. Multiple outputs separated by commas
	6: 'bdv', // Works like 'adv' but stored in register B, numerator is still read from register A
	7: 'cdv'  // Works like 'adv' but stored register C, numerator is still read from register A
}
let _OPERANDS = {
	0: 0,
	1: 1,
	2: 2,
	3: 3,
	4: 'A',
	5: 'B',
	6: 'C',
	7: null
}


_TIMERS.part_1 = performance.now(); // Start the timer for part 1
_ANSWERS.part1 = solvePart1(registers, program);
logAnswer(_ANSWERS.part1, 1);

_TIMERS.part_2 = performance.now(); // Start the timer for part 2
_ANSWERS.part2 = solvePart2(registers, program);
logAnswer(_ANSWERS.part2, 2);

printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Array} registers - The computer's registers
 * @param {Array} program - The program to run
 */
function solvePart1(registers, program) {

	let answer = 0;

	let output = [];

	for (let i = 0; i < program.length; i++) {
		let opcode = program[i];
		let operand = program[i + 1];

		[registers, output, i] = executeInstruction(opcode, operand, {...registers}, output, i);
	}
	answer = output.join(',');
	return answer;
}

function getOperandValue(operand, registers) {
	if (operand > 3 && operand < 7) {
		switch (operand) {
			case 4:
				return registers.A;
			case 5:
				return registers.B;
			case 6:
				return registers.C;
		}
	}
	return operand;
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart2(registers, program, axs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], output = []) {

	let answer = 0;
	main:
	for (let ai = 0; ai < axs.length; ai++) {
		// if (curr === 7) break;
		let ax = axs[ai];
		if (ax % 1000000 === 0) {
			console.log(ax, output.join(','), program.join(','));
		}
		registers.A = ax;

		let program_out = solvePart1(registers, program).split(',').map(Number);
		console.log(program_out[0], program.at(-program_out.length), ax);

		if (program_out[0] === program.at(-program_out.length)) {
			output.push(program_out[0]);
			let new_axs = [];
			for (let new_ai = 0; new_ai <= 8; new_ai++) {
				new_axs.push(ax * 8 + new_ai);
			}
			output = solvePart2(registers, program, new_axs, output);

			if (output.length === program.length) {
				if (output.join(',') === program.join(',')) {
					answer = ax;
					break main;
				}
			}
		}
	}
	if (answer === 0) {
		return 'No answer found';
	}
	return answer;
}

function recurse(axs, registers, program, target, output) {
	if (curr === 8) return false;

}

function executeInstruction(opcode, operand, registers, output, i) {
	switch (opcode) {
		case 0:
			registers.A = Math.trunc(registers.A / Math.pow(2, getOperandValue(operand, registers)));
			i++;
			break;
		case 1:
			registers.B = registers.B ^ operand;
			i++;
			break;
		case 2:
			registers.B = getOperandValue(operand, registers) % 8;
			i++;
			break;
		case 3:
			if (registers.A !== 0) {
				i = operand - 1;
			} else {
				i++;
			}
			break;
		case 4:
			registers.B = registers.B ^ registers.C;
			i++;
			break;
		case 5:
			output.push(getOperandValue(operand, registers) % 8);
			i++;
			break;
		case 6:
			registers.B = Math.floor(registers.A / Math.pow(2, getOperandValue(operand, registers)));
			i++;
			break;
		case 7:
			registers.C = Math.floor(registers.A / Math.pow(2, getOperandValue(operand, registers)));
			i++;
	}
	// console.log(opcode, operand, registers);

	return [registers, output, i];
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {

	let data = input.split('\n\n');
	let registers = {};
	data[0].split('\n').map(line => {
		let [_, register, value] = line.match(/(\w+): (\d+)/);
		registers[register] = Number(value);
	})
	let program = data[1].match(/\d+/g).map(Number);

	return [registers, program];

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Check if a given coordinate is within the bounds of a grid
 * @param {Array} grid - The grid to check against
 * @param {Number} x - The x coordinate to check
 * @param {Number} y - The y coordinate to check
 * @returns {Boolean} - Whether the coordinate is within the grid
 */
function isWithinBounds(grid, x, y) {
	return x >= 0 && x < grid[0].length && y >= 0 && y < grid.length;
}

/**
 * Print a given grid to the console
 * @param {Array} grid - The grid to print
 */
function printGrid(grid, reverse = false) {
	let out = '';
	if (reverse) grid = grid.reverse();
	grid.forEach(row => {
		out += row.join('') + '\n';
	});
	console.log(out);
}

/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Pick the best time unit for a given time
 * @param {Number} time - The time to pick a unit for
 * @returns {Array} - An array with the time and the unit
 */
function pickTimeUnit(time) {
	if (time < 1) return [time * 1000, 'Âµs'];
	else if (time < 1000) return [time, 'ms'];
	else if (time < 60000) return [time / 1000, 's'];
	else if (time < 3600000) return [time / 60000, 'm'];
	else return [time / 3600000, 'h'];
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function logAnswer(answer, part) {
	let time = performance.now();
	time = time - _TIMERS[`part_${part}`];
	let time_unit = pickTimeUnit(time);
	let static_length = 31;
	let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Part ' + part + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-] in'), chalk.green.bold('[- ' + (time_unit[0]).toFixed(4)), chalk.red(time_unit[1]), chalk.green.bold('-]'));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}

function logBothAnswers(answers) {
	let time = performance.now();
	time = time - _TIMERS['both'];
	let static_length = 12;
	let time_unit = pickTimeUnit(time);
	answers.forEach((answer, i) => {
		let line_length = static_length + answer.toString().length + time_unit[0].toFixed(4).length;
		let output = chalk(chalk.bold.white('Part ' + (i + 1) + ' [-'), chalk.yellow.bold(answer), chalk.white.bold('-]'));
		console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	})
	static_length =35
	let line_length = static_length + time_unit[0].toFixed(4).length;
	let output = chalk(chalk.bold.white('Time For Both Parts: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
}


/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.log('\n');
	let title = `-= DAY ${day} =-`;
	let line_length = (_OUTPUT_LENGTH - (title.length) - 2) / 4;
	console.info(chalk.bold.blue('-'.repeat(Math.ceil(line_length)), `${chalk.bold.white(title)}`, '-'.repeat(line_length * 3)));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	let time = performance.now();
	time = time - _TIMERS.global;
	let time_unit = pickTimeUnit(time);
	let static_length = 26;
	let line_length = static_length + time.toFixed(4).length;
	let output = chalk(chalk.bold.white('Total Time: [-'), chalk.green.bold(time_unit[0].toFixed(4), chalk.red(time_unit[1]), chalk.white('-]')));
	console.info(chalk.bold.white('---'), output, chalk.bold.white('-'.repeat(Math.abs(_OUTPUT_LENGTH - line_length))));
	console.log('\n');
}
// ************ End of Helper Functions ************