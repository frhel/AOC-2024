// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '04'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
console.log(process.argv)

const _FILES = {'problem': 'in.txt', 'example': 'ex.txt'}; // Input files for the problem and the example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _STARS = {'filled': '★', 'empty': '☆'}; // Pretty stars for the console output
_STARS.line_short = _STARS.filled.repeat(20); // Add a line of stars for separation
_STARS.line_long = _STARS.filled.repeat(56); // Add a longer line of stars for bigger separation

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
const _DIRNAME = {'1,1': 'SE', '-1,1': 'SW', '1,-1': 'NE', '-1,-1': 'NW', '0,1': 'S', '1,0': 'E', '0,-1': 'N', '-1,0': 'W'}; // Direction names
let input = readInputFile();
let data = parseInput(input);
solvePart1(data);
solvePart2(data);
printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart1(data) {
	_TIMERS.part_1 = performance.now(); // Start the timer for part 1

	const dirs = [[1,1], [-1,1], [1,-1], [-1,-1], [0,1], [1,0], [0,-1], [-1,0]]; // All directions
	const needle = 'XMAS';
	let answer = 0;

	for (let i = 0; i < data.length; i++) {
		let row = data[i];
		for (let j = 0; j < row.length; j++) {
			if (row[j] !== 'X') { continue; }
			let needleIdx = 1;
			let [x, y] = [j, i];
			for (let [dx, dy] of dirs) {
				if (crawl(x, y, dx, dy, data, needle, needleIdx)) {
					// console.log('Found at', x, y, 'in direction', _DIRNAME[stringCoords(dx, dy)]);
					answer += 1;
				}
			}
		}
	}

	log_answer(answer, 1);
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart2(data) {
	_TIMERS.part_2 = performance.now(); // Start the timer for part 2

	const needle = 'MAS'.split('').sort().reverse();
	const diags = [[[-1, -1], [1, 1]], [[1, -1], [-1, 1]]];
	let answer = 0;

	for (let i = 0; i < data.length; i++) {
		let row = data[i];
		for (let j = 0; j < row.length; j++) {
			let n_copy = [...needle];
			let x_diag = {'nw_se': {'found': [n_copy.pop()], needle: [...n_copy]}};
			x_diag.ne_sw = {'found': [...x_diag.nw_se.found], needle: [...n_copy]};
			if (row[j] !== x_diag.nw_se.found[0]) { continue; }

			// Check NW-SE Diagonal
			let [x, y] = [j, i];
			let found = 0;
			let diags_to_check = [x_diag.nw_se, x_diag.ne_sw];
			for (let diag of diags) {
				let curr_diag = diags_to_check.pop();
				for (let [dx, dy] of diag) {
					let [nx, ny] = [x + dx, y + dy];
					if (outOfBounds(nx, ny, data)) { break; }
					let char = data[ny][nx];
					if (curr_diag.needle.includes(char)) {
						curr_diag.found = char;
						let idx = curr_diag.needle.indexOf(char);
						curr_diag.needle.splice(idx, 1);
						if (curr_diag.needle.length === 0) {
							found += 1;
						}
					}
				}
			}
			if (found === 2) { answer += 1; }
		}
	}
	log_answer(answer, 2);
}

function crawl(x, y, dx, dy, data, needle, needleIdx) {
	let [nx, ny] = [x + dx, y + dy];
	if (outOfBounds(nx, ny, data)
		|| data[ny][nx] !== needle[needleIdx]
	){ return false; }
	if (needleIdx === needle.length - 1) {
		return true;
	}
	return crawl(nx, ny, dx, dy, data, needle, needleIdx + 1);
}

function stringCoords(x, y) {
	return `${x},${y}`;
}


function outOfBounds(x, y, data) {
	return x < 0 || y < 0 || y >= data.length || x >= data[y].length;
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {

	return input.split('\n').map(x => x.split(''));

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function log_answer(answer, part) {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(3), chalk.bold.white('Part ' + part), ' '.repeat(3), chalk.blue(_STARS.line_short));
	console.info(_STARS.filled.repeat(2), chalk.cyan('Answer: '), '[-', chalk.yellow.bold(answer), '-] in', chalk.green('[-'), chalk.green.bold((performance.now() - _TIMERS[`part_${part}`]).toFixed(4)), chalk.red('ms'), chalk.green('-]\n'));
}

/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.info(chalk.blue(`\n${_STARS.line_short} ${chalk.bold.white('DAY .-[',_DAY,']-.')} ${_STARS.line_short}\n`));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(1), chalk.bold.white('Total Time'), ' '.repeat(1), chalk.blue(_STARS.line_short));
	console.info(chalk.blue(_STARS.filled.repeat(23)), chalk.green.bold((performance.now() - _TIMERS['global']).toFixed(4))+chalk.bold.white('ms'), chalk.blue(_STARS.filled.repeat(23)), '\n');
}
// ************ End of Helper Functions ************
