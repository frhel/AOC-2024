// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '04'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
console.log(process.argv)

const _FILES = {'problem': 'in.txt', 'example': 'ex.txt'}; // Input files for the problem and the example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _STARS = {'filled': '★', 'empty': '☆'}; // Pretty stars for the console output
_STARS.line_short = _STARS.filled.repeat(20); // Add a line of stars for separation
_STARS.line_long = _STARS.filled.repeat(56); // Add a longer line of stars for bigger separation

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge
// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let input = readInputFile();
let data = parseInput(input);
solvePart1(data);
solvePart2(data);
printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart1(data) {
	_TIMERS.part_1 = performance.now(); // Start the timer for part 1

	const haystack = [...data]; // Grid to search
	const needle = 'XMAS'; // Needle to search for

	// Define all possible directions as relative coordinates in increments of 1
	// This allows us to easily check all directions from a given point by doing
	// simple addition of the current coordinates and the direction coordinates
	// Ex: [0,1] + [-1,1] = [-1,2] which is the coordinate to the top right of the current point
	//     to continue in that direction we would add [-1,1] again to get [-2,3] and so on
	const directions = [[1,1], [-1,1], [1,-1], [-1,-1], [0,1], [1,0], [0,-1], [-1,0]];

	let answer = 0;

	// Loop through the grid and check each point for the first character of the needle.
	// If the character is found, start a recursive search in all directions to see if there are one or more needles to be found
	for (let y = 0; y < haystack.length; y++) {
		let row = haystack[y];
		for (let x = 0; x < row.length; x++) {
			if (row[x] !== needle[0]) { continue; } // Skip if the current character is not the first character of the needle
			let needleIdx = 1; // Index of the next character to search for
			for (let [dx, dy] of directions) { // Check all directions one by one
				// Start recursive search for the rest of the needle in the current direction of dx, dy
				// Add the result to the answer. If the result is true it will add 1, if false it will add 0
				answer += crawl_all_axis(x, y, -dx, -dy, haystack, needle, needleIdx);
			}
		}
	}

	log_answer(answer, 1);
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart2(data) {
	_TIMERS.part_2 = performance.now(); // Start the timer for part 2

	const haystack = [...data]; // Grid to search

	// A Convoluted way to sort the needle in reverse order so we can pop the last character as the base token
	const needle = ['M', 'S'];
	const needle_start = 'A'; // Base token to perform the rest of the search around

	// Define the directions to search as relative coordinates in increments of 1
	// This allows us to easily check all directions from a given point by doing
	// simple addition of the current coordinates and the direction coordinates
	// Ex: [0,1] + [-1,1] = [-1,2] which is the coordinate to the top right of the current point
	// Since our search space is an X shape, we only need to check two directions on the diagonal axis
	const diagonals = [
		[[-1, -1], [1, 1]],
		[[1, -1], [-1, 1]]
	];
	let answer = 0;

	// Loop through the grid and check each point for the trigger character
	for (let y = 0; y < haystack.length; y++) {
		let row = haystack[y];
		for (let x = 0; x < row.length; x++) {
			if (row[x] !== needle_start) { continue; } // Skip if the current character is not the trigger character

			let found = true; // Assume we have found the needle until proven otherwise
			for (let diagonal of diagonals) { // Check both diagonal directions
				found = check_diagonals(x, y, haystack, diagonal, [...needle]); // Check if the full needle is found in the diagonal
				if (!found) { break; } // Break if the needle is not found in the current diagonal. If one diagonal fails, the whole search fails
			}
			answer += found; // Add the result to the answer. If the result is true it will add 1, if false it will add 0
		}
	}
	log_answer(answer, 2);
}

/**
 * Check only the X shape diagonals for full needle matches
 * @param {Number} x - The x coordinate to start the search from
 * @param {Number} y - The y coordinate to start the search from
 * @param {Array} haystack - The grid to search in
 * @param {Array} diagonal - The relative coordinates to search in
 * @param {Array} needle - The needle to search for
 * @returns {Boolean} - True if the needle is found, false otherwise
 */
function check_diagonals(x, y, haystack, diagonal, needle) {
	// Loop through each relative coordinate in the diagonal to check for the remaining characters of the needle
	for (let [dx, dy] of diagonal) {
		let [nx, ny] = [x + dx, y + dy]; // Next coords
		if (outOfBounds(nx, ny, haystack)) { break; } // Break if we are looking outside the grid

		let char = haystack[ny][nx]; // Current character
		if (!needle.includes(char)) { break; } // Break if the character is not a needle character

		needle.splice(needle.indexOf(char), 1); // Remove the character from the needle
		if (needle.length === 0) {	return true; } // Return if the whole needle has been found
	}
	// If we have not already returned we have not found the needle so return 0
	return false;
}

/**
 * Recursively crawl in a given direction to check for the full needle
 * @param {Number} x - The x coordinate to start the search from
 * @param {Number} y - The y coordinate to start the search from
 * @param {Number} dx - The x direction to search in
 * @param {Number} dy - The y direction to search in
 * @param {Array} haystack - The grid to search in
 * @param {Array} needle - The needle to search for
 * @param {Number} needleIdx - The index of the next character to search for
 * @returns {Boolean} - True if the needle is found, false otherwise
 */
function crawl_all_axis(x, y, dx, dy, haystack, needle, needleIdx) {
	let [nx, ny] = [x + dx, y + dy]; // Next coords
	// Break if we are looking outside the grid or the character is not in sequence
	if (outOfBounds(nx, ny, haystack) || haystack[ny][nx] !== needle[needleIdx]){ return false; }
	if (needleIdx === needle.length - 1) { return true; } // Return if the whole needle has been found

	// Recursively check the next character if we have found a partial match so far
	// Use the same direction, but increment the x and y values to match the currently checked coordinates
	// Increment the needle index to check the next character
	// For more information on the recursion, see https://www.youtube.com/watch?v=rf60MejMz3E
	return crawl_all_axis(nx, ny, dx, dy, haystack, needle, needleIdx + 1);
}

/**
 * Check if the coordinates are outside the grid
 * @param {Number} x - The x coordinate to check
 * @param {Number} y - The y coordinate to check
 * @param {Array} haystack - The grid to check against
 * @returns {Boolean} - True if the coordinates are outside the grid, false otherwise
 */
function outOfBounds(x, y, haystack) {
	// Check if the coordinates are outside the grid
	// Read more about the bounds of a 2D array here: https://stackoverflow.com/questions/29808883/how-to-check-if-a-2d-array-is-out-of-bounds
	return x < 0 || y < 0 || y >= haystack.length || x >= haystack[y].length;
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {

	return input.split('\n').map(x => x.split(''));

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function log_answer(answer, part) {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(3), chalk.bold.white('Part ' + part), ' '.repeat(3), chalk.blue(_STARS.line_short));
	console.info(_STARS.filled.repeat(2), chalk.cyan('Answer: '), '[-', chalk.yellow.bold(answer), '-] in', chalk.green('[-'), chalk.green.bold((performance.now() - _TIMERS[`part_${part}`]).toFixed(4)), chalk.red('ms'), chalk.green('-]\n'));
}

/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.info(chalk.blue(`\n${_STARS.line_short} ${chalk.bold.white('DAY .-[',_DAY,']-.')} ${_STARS.line_short}\n`));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(1), chalk.bold.white('Total Time'), ' '.repeat(1), chalk.blue(_STARS.line_short));
	console.info(chalk.blue(_STARS.filled.repeat(23)), chalk.green.bold((performance.now() - _TIMERS['global']).toFixed(4))+chalk.bold.white('ms'), chalk.blue(_STARS.filled.repeat(23)), '\n');
}
// ************ End of Helper Functions ************
