// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '06'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _STARS = {'filled': '★', 'empty': '☆'}; // Pretty stars for the console output
_STARS.line_short = _STARS.filled.repeat(20); // Add a line of stars for separation
_STARS.line_long = _STARS.filled.repeat(56); // Add a longer line of stars for bigger separation

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let _DIRS = [[0, -1], [1, 0], [0, 1], [-1, 0]]; // Up, Right, Down, Left
let _OBSTACLE = '#'; // Obstacle symbol
let _VISITED = new Set(); // Visited cells
let _START_DIR = 0; // Start direction
let input = readInputFile();
let data = parseInput(input);
let _GRID = data[0];
let _GRID_BOUNDS = [_GRID[0].length, _GRID.length];
solvePart1(data[1], data[2]);
solvePart2(data[1], data[2]);
printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 */
function solvePart1(x, y) {
	_TIMERS.part_1 = performance.now(); // Start the timer for part 1

	log_answer(runSimulation(x, y), 1);
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 */
function solvePart2(x, y) {
	_TIMERS.part_2 = performance.now(); // Start the timer for part 2

	let answer = 0;
	_GRID.forEach((row, r) => {
		row.forEach((cell, c) => {
			// Skip if the cell is an obstacle or the starting point
			if (cell.symbol === '#' || cell.symbol === "^") return;
			_GRID[r][c].symbol = '#'; // Set the cell as an obstacle
			// Run the simulation and increment the answer if the simulation returns true
			answer += runSimulation(x, y, 2) ? 1 : 0;
			// Reset the cell to its original state
			_GRID[r][c].symbol = '.';
		})
	})

	log_answer(answer, 2);
}

/**
 * Runs the simulation
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 * @param {Number} part - The part of the challenge
 */
function runSimulation(x, y, part = 1) {
	let dir = _START_DIR; // Always start facing up
	_VISITED = new Set([_GRID[y][x].key]) // Reset the visited cells
	let last_visited_size = _VISITED.size; // Keep track of the last visited size
	let nx, ny; // Next x and y coordinates
	while (true) {
		// Setting the nx and ny values to the next cell while checking if the next cell is inside the bounds
		// seems to be a little faster than setting the values before making the check. Maybe not...
		nx = x + _DIRS[dir][0]; ny = y + _DIRS[dir][1];
		if (!isInsideBounds(nx, ny)) break;

		// If the next cell is an obstacle, change direction and continue
		if (_GRID[ny][nx].symbol === _OBSTACLE) {
			dir = (dir + 1) % 4;
			continue;
		}

		// Update the coordinates for the guards current position
		x = nx;	y = ny;
		if (part === 1) {
			// Add the basic coordinates to the visited set for part 1
			_VISITED.add(_GRID[y][x].key);
			continue;
		}

		// Keep track of the size of the visited set before adding the key for the coordinates with direction
		last_visited_size = _VISITED.size;

		// If not part 1, add the key for the coordinates with direction to the visited set
		_VISITED.add(_GRID[y][x].keys[dir]);

		// Check if the size of the visited set has changed.
		// This is faster than checking if the key is already in the set
		if (last_visited_size === _VISITED.size) {
			// If there was no change in the visited set size, we have
			// visited this cell with this direction before, so we have
			// found a loop and can return true
			return true;
		}
	}

	if (part === 2) return false;
	return _VISITED.size;
}

/**
 * Check if the coordinates are inside the bounds of the grid
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 * @returns {Boolean} - True if the coordinates are inside the bounds, false otherwise
 */
function isInsideBounds(x, y) {
	return x >= 0 && x < _GRID_BOUNDS[0] && y >= 0 && y < _GRID_BOUNDS[1];
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {

	let grid = input.split('\n').map(row => row.split(''));

	let x = 0;
	let y = 0;
	grid.forEach((row, r) => {
		if (row.includes('^')) {
			x = row.indexOf('^');
			y = r;
		}
		row.forEach((cell, c) => {
			// Set the cell as an object with the symbol and the keys for the cell
			// Offloading cpu work to memory by storing keys. This is faster than
			// generating the keys on the fly
			grid[r][c] = {symbol: cell, keys: [`${c},${r};0`, `${c},${r};1`, `${c},${r};2`, `${c},${r};3`], key: `${c},${r}`};
		});
	})

	return [grid, x, y];

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function log_answer(answer, part) {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(3), chalk.bold.white('Part ' + part), ' '.repeat(3), chalk.blue(_STARS.line_short));
	console.info(_STARS.filled.repeat(2), chalk.cyan('Answer: '), '[-', chalk.yellow.bold(answer), '-] in', chalk.green('[-'), chalk.green.bold((performance.now() - _TIMERS[`part_${part}`]).toFixed(4)), chalk.red('ms'), chalk.green('-]'));
}

/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.info(chalk.blue(`\n${_STARS.line_short} ${chalk.bold.white('DAY .-[',_DAY,']-.')} ${_STARS.line_short}`));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(1), chalk.bold.white('Total Time'), ' '.repeat(1), chalk.blue(_STARS.line_short));
	console.info(chalk.blue(_STARS.filled.repeat(23)), chalk.green.bold((performance.now() - _TIMERS['global']).toFixed(4))+chalk.bold.white('ms'), chalk.blue(_STARS.filled.repeat(23)));
}
// ************ End of Helper Functions ************
