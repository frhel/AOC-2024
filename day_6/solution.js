// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output
import { Worker, isMainThread } from 'worker_threads'; // Worker threads for multi-threading

// Define Generic Global Variables
const _DAY = '06'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _STARS = {'filled': '★', 'empty': '☆'}; // Pretty stars for the console output
_STARS.line_short = _STARS.filled.repeat(20); // Add a line of stars for separation
_STARS.line_long = _STARS.filled.repeat(56); // Add a longer line of stars for bigger separation

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let _DIRS = [[0, -1], [1, 0], [0, 1], [-1, 0]]; // Up, Right, Down, Left
let _OBSTACLE = '#'; // Obstacle symbol
let _ACTIVE_POINTS = new Map(); // Active points
let _START_DIR = 0; // Start direction
let input = readInputFile();
let data = await parseInput(input);
let _GRID = data[0];
let _GRID_BOUNDS = [_GRID[0].length, _GRID.length];
solvePart1(data[1], data[2]);
await solvePart2(data[1], data[2]);
printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 */
function solvePart1(x, y) {
	_TIMERS.part_1 = performance.now(); // Start the timer for part 1

	_ACTIVE_POINTS = runSimulation(x, y);
	log_answer(_ACTIVE_POINTS.size, 1);
}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 */
async function solvePart2(x, y) {
	_TIMERS.part_2 = performance.now(); // Start the timer for part 2

	let answer = 0;

	let workers = [];

	let points = Array.from(_ACTIVE_POINTS);
	const thread_count = 10;
	let part_size = Math.ceil(points.length / thread_count);
	for (let i = 0; i < thread_count * part_size; i += part_size) {
		workers.push(
			new Promise((resolve, reject) => {
				const worker = new Worker('./simulation.js', {
					workerData: {grid: _GRID, points: points.slice(i, i + part_size), x: x, y: y}
				});
				worker.on('message', (message) => {
					answer += message;
					resolve();
				});
				worker.on('error', reject);
				worker.on('exit', (code) => {
					if (code !== 0)
						reject(new Error(`Worker stopped with exit code ${code}`));
				});
			}
		));
	}

	await Promise.all(workers);

	log_answer(answer, 2);
}

/**
 * Runs the simulation
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 * @param {Number} part - The part of the challenge
 */
function runSimulation(x, y, part = 1, grid = _GRID) {
	let dir = _START_DIR; // Always start facing up
	let visited = new Map([[grid[y][x].key, [x, y]]]); // Set to keep track of visited cells
	let nx, ny; // Next x and y coordinates
	while (true) {
		// Setting the nx and ny values to the next cell while checking if the next cell is inside the bounds
		// seems to be a little faster than setting the values before making the check. Maybe not...
		nx = x + _DIRS[dir][0]; ny = y + _DIRS[dir][1];
		if (!isInsideBounds(nx, ny)) break;

		// If the next cell is an obstacle, change direction and continue
		if (grid[ny][nx].symbol === _OBSTACLE) {
			dir = (dir + 1) % 4;
			continue;
		}

		// Update the coordinates for the guards current position
		x = nx;	y = ny;
		// Add the basic coordinates to the visited set for part 1
		visited.set(grid[y][x].key, [x, y]);
		continue;
	}

	if (part === 2) return false;
	return visited
}

/**
 * Check if the coordinates are inside the bounds of the grid
 * @param {Number} x - The x coordinate
 * @param {Number} y - The y coordinate
 * @returns {Boolean} - True if the coordinates are inside the bounds, false otherwise
 */
function isInsideBounds(x, y) {
	return x >= 0 && x < _GRID_BOUNDS[0] && y >= 0 && y < _GRID_BOUNDS[1];
}


/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {

	let grid = input.split('\n').map(row => row.split(''));

	let x = 0;
	let y = 0;
	grid.forEach((row, r) => {
		if (row.includes('^')) {
			x = row.indexOf('^');
			y = r;
		}
		row.forEach((cell, c) => {
			// Set the cell as an object with the symbol and the keys for the cell
			// Offloading cpu work to memory by storing keys. This is faster than
			// generating the keys on the fly
			grid[r][c] = {symbol: cell, keys: [`${c},${r};0`, `${c},${r};1`, `${c},${r};2`, `${c},${r};3`], key: `${c},${r}`};
		});
	})

	return [grid, x, y];

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function log_answer(answer, part) {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(3), chalk.bold.white('Part ' + part), ' '.repeat(3), chalk.blue(_STARS.line_short));
	console.info(_STARS.filled.repeat(2), chalk.cyan('Answer: '), '[-', chalk.yellow.bold(answer), '-] in', chalk.green('[-'), chalk.green.bold((performance.now() - _TIMERS[`part_${part}`]).toFixed(4)), chalk.red('ms'), chalk.green('-]'));
}

/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.info(chalk.blue(`\n${_STARS.line_short} ${chalk.bold.white('DAY .-[',_DAY,']-.')} ${_STARS.line_short}`));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	console.info(chalk.blue(_STARS.line_short), ' '.repeat(1), chalk.bold.white('Total Time'), ' '.repeat(1), chalk.blue(_STARS.line_short));
	console.info(chalk.blue(_STARS.filled.repeat(23)), chalk.green.bold((performance.now() - _TIMERS['global']).toFixed(4))+chalk.bold.white('ms'), chalk.blue(_STARS.filled.repeat(23)));
}
// ************ End of Helper Functions ************
