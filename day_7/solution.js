// ************ Initalization Stuff ************
import fs from 'fs'; // File system module
import chalk from 'chalk'; // Colorizes console output

// Define Generic Global Variables
const _DAY = '07'; // Auto-generated by create.sh script. See README.md for details: https://github.com/frhel/AOC-2024/blob/main/README.md

const _FILE = process.argv[2] || 'in.txt'; // Default input file0 for problem input, 1 for example. Default is 1 for example
const _TIMERS = {'global': performance.now(), 'part_1': '', 'part_2': ''}; // Object to keep track of individual timers
const _STARS = {'filled': '★', 'empty': '☆'}; // Pretty stars for the console output
_STARS.line_short = _STARS.filled.repeat(20); // Add a line of stars for separation
_STARS.line_long = _STARS.filled.repeat(56); // Add a longer line of stars for bigger separation

printDayTitlePlate(_DAY); // Print a plate with the day of the challenge

// ************ End of Initalization ***********

// ************ Main Logic Stuff ************
let _REJECTS = [];
let _OPERATORS = ['+', '*'];
let _PART_1_ANSWER = 0;
let input = readInputFile();
let data = parseInput(input);
solvePart1(data);
solvePart2(data);
printTotalTime();

// ************ Solution Functions ************
/**
 * Solves part 1 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart1(data) {
	_TIMERS.part_1 = performance.now(); // Start the timer for part 1

	let answer = 0;

	// Deep copy the data array to avoid modifying the original for part 2
	let data_copy = [];
	for (let i = 0; i < data.length; i++) data_copy.push([data[i][0], [...data[i][1]]]);

	// Iterate over the data and solve the problem
	for (let i = 0; i < data.length; i++) {
		// Recurse through the data and find if the test is possible or not
		let res = recursePart1(data_copy[i][0], data_copy[i][1][0], data_copy[i][1][1], data_copy[i][1].slice(2));
		answer += res;
		// Any tests that return 0 are added to the _REJECTS array for part 2
		if (res === 0) _REJECTS.push(i);
	}

	// Save the answer to the global variable for part 2
	_PART_1_ANSWER = answer;

	log_answer(answer, 1);

}

/**
 * Solves part 2 of the challenge and logs the answer to the console
 * @param {Array} data - The parsed input data
 */
function solvePart2(data) {
	_TIMERS.part_2 = performance.now(); // Start the timer for part 2

	let answer = 0;
	// Iterate over the _REJECTS array and only solve the tests that failed part 1
	for (let i = 0; i < _REJECTS.length; i++) {
		let res = recursePart2(data[_REJECTS[i]][0], data[_REJECTS[i]][1][0], data[_REJECTS[i]][1][1], data[_REJECTS[i]][1].slice(2));
		answer += res; // Add the result to the answer. 0 if not found
	}
	// Add the answer from part 1 to the answer from part 2
	log_answer(answer + _PART_1_ANSWER, 2);
}


function recursePart1(test, left, right, line) {
	let new_line = line.slice(1);
	// Create a new branch for each operation
	for (let operator of _OPERATORS) {
		// Perform the operation
		let outcome = operator === '+' ? left + right : left * right;
		// If the outcome is greater than the test, skip this branch as it will not be possible
		// to reduce the accumulated number to match the test
		if (outcome > test) continue;

		// If there are more numbers in the line, recurse through the rest of the line with the outcome added to the front
		if (line.length > 0) {
			let res = recursePart1(test, outcome, line[0], new_line);
			if (res === test) return res;
		}
		if (outcome === test) return outcome;
	}
	return 0;
}

function recursePart2(test, left, right, line) {
	// If the line is only one element, return it if it matches the test
	if (line.length === 0) if (left === test) return left;
	let new_line = line.slice(1);


	// Create a new branch for each operation
	for (let operator of _OPERATORS) {
		// Perform the operation
		let outcome = operator === '+' ? left + right : left * right;
		// If the outcome is greater than the test, skip this branch as it will not be possible
		if (outcome > test) continue;

		// IF we have more numbers in the line, recurse through the rest of the line with the outcome added to the front
		if (line.length > 0) {
			let res = recursePart2(test, outcome, line[0], new_line);
			if (res === test) return res;
		}

		// If the outcome matches the test, return it
		if (outcome === test) return outcome;
	}

	// Concatenate the left and right numbers and check if it is greater than the test
	let concat = Number(`${left}${right}`);

	// Kill the branch if the concatenated number is greater than the test as it is not possible
	// to reduce the accumulated number and we have overshot the test
	if (concat > test) return 0;

	// If there are more numbers in the line, recurse through the rest of the line with the concatenated number added to the front
	if (line.length > 0) {
		// Recurse through the rest of the line with the concatenated number added to the front
		let res = recursePart2(test, concat, line[0], new_line);
		if (res === test) return res;
	}
	// If the concatenated number matches the test, return it
	if (concat === test) return concat;

	// If no matches are found, return 0
	return 0;
}



/**
 * Parse the input into a usable format
 * Remember to set the @param and @returns values
 */
function parseInput(input) {
	// Returns [test, [numbers]]
	return input.split('\n').map((line) => line.split(' ')).map((line) => [Number(line[0].split(':')[0]), [...line.slice(1)].map((el) => Number(el))]);

}
// ************ End of Solution Functions ************
// ************ End of Main Logic Stuff ************


// ************ Helper Functions ************
/**
 * Read the input file
 * @returns {String} - The input file as a string
 */
function readInputFile() {
	// Selector for input file is set by _EXAMPLE variable at the top
	return fs
		.readFileSync(_FILE)
		.toString()
}

/**
 * Log the answer to the console
 * @param {Number} answer - The answer to log
 * @param {Number} part - The part of the _DAY
 */
function log_answer(answer, part) {
	let time = performance.now();
	time = time - _TIMERS[`part_${part}`];
	if (part === 1) console.info(chalk.blue('-'.repeat(40)));
	console.info(chalk.bold.white('Part ' + part), ' '.repeat(3), '[-', chalk.yellow.bold(answer), '-] in', chalk.green('[-'), chalk.green.bold((time).toFixed(4)), chalk.red('ms'), chalk.green('-]'));
	console.info(chalk.blue('-'.repeat(40)));
}

/**
 * Print the day title plate to the console
 * @param {String} day - The day of the challenge
 */
function printDayTitlePlate(day) {
	console.info(chalk.blue(`\n${_STARS.line_short} ${chalk.bold.white('DAY .-[',_DAY,']-.')} ${_STARS.line_short}`));
}

/**
 * Print the total time to the console
 */
function printTotalTime() {
	console.info(chalk.bold.white('Total Time: '), ' '.repeat(1), chalk.green.bold((performance.now() - _TIMERS['global']).toFixed(4))+chalk.bold.white('ms'));
	console.info(chalk.blue('-'.repeat(40)));
}
// ************ End of Helper Functions ************
